From 7dec90fae51f6b830a09c3b7c528f3936da14a09 Mon Sep 17 00:00:00 2001
From: Jarno Rajahalme <jarno@isovalent.com>
Date: Sun, 26 Feb 2023 22:41:24 +0200
Subject: [PATCH 5/9] router: Do not crash if SNI was already set with auto_sni

Avoid hitting the exception in setData() when keys are already set, maybe
by some filter, when processing the auto_sni option to prevent Envoy
crash due to un-catched exception.

This would be simpler with try/catch, but that is no longer allowed from
worker threads.

Signed-off-by: Jarno Rajahalme <jarno@isovalent.com>
---
 source/common/router/router.cc | 53 ++++++++++++++++++++++++++++------
 1 file changed, 44 insertions(+), 9 deletions(-)

diff --git a/source/common/router/router.cc b/source/common/router/router.cc
index 78a22c67be..50b249d641 100644
--- a/source/common/router/router.cc
+++ b/source/common/router/router.cc
@@ -1,5 +1,6 @@
 #include "source/common/router/router.h"
 
+#include <algorithm>
 #include <chrono>
 #include <cstdint>
 #include <functional>
@@ -540,18 +541,52 @@ Http::FilterHeadersStatus Filter::decodeHeaders(Http::RequestHeaderMap& headers,
     absl::string_view sni_value = parsed_authority.host_;
 
     if (should_set_sni && upstream_http_protocol_options.value().auto_sni()) {
-      callbacks_->streamInfo().filterState()->setData(
-          Network::UpstreamServerName::key(),
-          std::make_unique<Network::UpstreamServerName>(sni_value),
-          StreamInfo::FilterState::StateType::Mutable);
+      if (!callbacks_->streamInfo().filterState()->hasDataWithName(
+              Network::UpstreamServerName::key())) {
+        callbacks_->streamInfo().filterState()->setData(
+            Network::UpstreamServerName::key(),
+            std::make_unique<Network::UpstreamServerName>(sni_value),
+            StreamInfo::FilterState::StateType::Mutable);
+      } else {
+        auto* sni =
+            callbacks_->streamInfo().filterState()->getDataReadOnly<Network::UpstreamServerName>(
+                Network::UpstreamServerName::key());
+        if (!sni) {
+          ENVOY_STREAM_LOG(debug, "auto_sni: sni could not be set as {}", *callbacks_, sni_value);
+        } else if (sni->value() != sni_value) {
+          ENVOY_STREAM_LOG(debug, "auto_sni: sni could not be set as {}, already set as {}",
+                           *callbacks_, sni_value, sni->value());
+        }
+      }
     }
 
     if (upstream_http_protocol_options.value().auto_san_validation()) {
-      callbacks_->streamInfo().filterState()->setData(
-          Network::UpstreamSubjectAltNames::key(),
-          std::make_unique<Network::UpstreamSubjectAltNames>(
-              std::vector<std::string>{std::string(sni_value)}),
-          StreamInfo::FilterState::StateType::Mutable);
+      if (!callbacks_->streamInfo().filterState()->hasDataWithName(
+              Network::UpstreamSubjectAltNames::key())) {
+        callbacks_->streamInfo().filterState()->setData(
+            Network::UpstreamSubjectAltNames::key(),
+            std::make_unique<Network::UpstreamSubjectAltNames>(
+                std::vector<std::string>{std::string(sni_value)}),
+            StreamInfo::FilterState::StateType::Mutable);
+      } else {
+        auto* san = callbacks_->streamInfo()
+                        .filterState()
+                        ->getDataMutable<Network::UpstreamSubjectAltNames>(
+                            Network::UpstreamSubjectAltNames::key());
+        if (!san) {
+          ENVOY_STREAM_LOG(debug, "auto_san_validation: could not set subject alt name as {}",
+                           *callbacks_, sni_value);
+        } else {
+          auto& names = san->value();
+          if (std::find(names.begin(), names.end(), sni_value) == names.end()) {
+
+            ENVOY_STREAM_LOG(
+                debug,
+                "auto_san_validation: could not set subject alt name as {}, already set as {}",
+                *callbacks_, sni_value, names);
+          }
+        }
+      }
     }
   }
 
-- 
2.39.2

