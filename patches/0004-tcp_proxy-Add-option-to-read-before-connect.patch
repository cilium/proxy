From 8eda35d0c057eae266c9ed95d91446f0bde9e0fb Mon Sep 17 00:00:00 2001
From: Jarno Rajahalme <jarno@isovalent.com>
Date: Tue, 27 Sep 2022 15:51:46 +0300
Subject: [PATCH 4/6] tcp_proxy: Add option to read before connect

Signed-off-by: Jarno Rajahalme <jarno@isovalent.com>
---
 .../network/tcp_proxy/v3/tcp_proxy.proto      |  5 ++++
 source/common/tcp_proxy/tcp_proxy.cc          | 24 ++++++++++++++++---
 source/common/tcp_proxy/tcp_proxy.h           |  6 +++++
 3 files changed, 32 insertions(+), 3 deletions(-)

diff --git a/api/envoy/extensions/filters/network/tcp_proxy/v3/tcp_proxy.proto b/api/envoy/extensions/filters/network/tcp_proxy/v3/tcp_proxy.proto
index 6e6f39eca6..a8d189de6b 100644
--- a/api/envoy/extensions/filters/network/tcp_proxy/v3/tcp_proxy.proto
+++ b/api/envoy/extensions/filters/network/tcp_proxy/v3/tcp_proxy.proto
@@ -212,4 +212,9 @@ message TcpProxy {
   // The interval must be at least 1ms.
   google.protobuf.Duration access_log_flush_interval = 15
       [(validate.rules).duration = {gte {nanos: 1000000}}];
+
+  // Keep downstream read enabled before connecting upstream.
+  // Note that enabling this may cause data to stall if preceding filter(s) do not buffer and/or
+  // re-inject data after the upstream connection has been established.
+  bool receive_before_connect = 16;
 }
diff --git a/source/common/tcp_proxy/tcp_proxy.cc b/source/common/tcp_proxy/tcp_proxy.cc
index fc28bf5e13..88af6f1e4d 100644
--- a/source/common/tcp_proxy/tcp_proxy.cc
+++ b/source/common/tcp_proxy/tcp_proxy.cc
@@ -100,6 +100,8 @@ Config::SharedConfig::SharedConfig(
     on_demand_config_ =
         std::make_unique<OnDemandConfig>(config.on_demand(), context, *stats_scope_);
   }
+
+  receive_before_connect_ = config.receive_before_connect();
 }
 
 Config::Config(const envoy::extensions::filters::network::tcp_proxy::v3::TcpProxy& config,
@@ -221,7 +223,9 @@ void Filter::initialize(Network::ReadFilterCallbacks& callbacks, bool set_connec
   // Need to disable reads so that we don't write to an upstream that might fail
   // in onData(). This will get re-enabled when the upstream connection is
   // established.
-  read_callbacks_->connection().readDisable(true);
+  if (!config_->receiveBeforeConnect()) {
+    read_callbacks_->connection().readDisable(true);
+  }
   getStreamInfo().setDownstreamBytesMeter(std::make_shared<StreamInfo::BytesMeter>());
   getStreamInfo().setUpstreamInfo(std::make_shared<StreamInfo::UpstreamInfoImpl>());
 
@@ -432,8 +436,11 @@ Network::FilterStatus Filter::establishUpstreamConnection() {
     // cluster->trafficStats()->upstream_cx_none_healthy in the latter case.
     getStreamInfo().setResponseFlag(StreamInfo::ResponseFlag::NoHealthyUpstream);
     onInitFailure(UpstreamFailureReason::NoHealthyUpstream);
+    return Network::FilterStatus::StopIteration;
   }
-  return Network::FilterStatus::StopIteration;
+  // Allow OnData() to receive data before connect if so configured
+  return config_->receiveBeforeConnect()
+       ? Network::FilterStatus::Continue : Network::FilterStatus::StopIteration;
 }
 
 void Filter::onClusterDiscoveryCompletion(Upstream::ClusterDiscoveryStatus cluster_status) {
@@ -632,6 +639,12 @@ Network::FilterStatus Filter::onData(Buffer::Instance& data, bool end_stream) {
   if (upstream_) {
     getStreamInfo().getUpstreamBytesMeter()->addWireBytesSent(data.length());
     upstream_->encodeData(data, end_stream);
+  } else if (config_->receiveBeforeConnect()) {
+    // Buffer data received before upstream connection exists
+    early_data_buffer_.move(data);
+    if (!early_data_end_stream_) {
+      early_data_end_stream_ = end_stream;
+    }
   }
   // The upstream should consume all of the data.
   // Before there is an upstream the connection should be readDisabled. If the upstream is
@@ -745,7 +758,12 @@ void Filter::onUpstreamConnection() {
   connecting_ = false;
   // Re-enable downstream reads now that the upstream connection is established
   // so we have a place to send downstream data to.
-  read_callbacks_->connection().readDisable(false);
+  if (!config_->receiveBeforeConnect()) {
+    read_callbacks_->connection().readDisable(false);
+  } else if (early_data_buffer_.length() > 0) {
+    upstream_->encodeData(early_data_buffer_, early_data_end_stream_);
+    ASSERT(0 == early_data_buffer_.length());
+  }
 
   read_callbacks_->upstreamHost()->outlierDetector().putResult(
       Upstream::Outlier::Result::LocalOriginConnectSuccessFinal);
diff --git a/source/common/tcp_proxy/tcp_proxy.h b/source/common/tcp_proxy/tcp_proxy.h
index 324e933192..548cdc780f 100644
--- a/source/common/tcp_proxy/tcp_proxy.h
+++ b/source/common/tcp_proxy/tcp_proxy.h
@@ -22,6 +22,7 @@
 #include "envoy/upstream/cluster_manager.h"
 #include "envoy/upstream/upstream.h"
 
+#include "source/common/buffer/buffer_impl.h"
 #include "source/common/common/logger.h"
 #include "source/common/formatter/substitution_format_string.h"
 #include "source/common/http/header_map_impl.h"
@@ -216,6 +217,7 @@ public:
         return {};
       }
     }
+    bool receiveBeforeConnect() { return receive_before_connect_; }
 
   private:
     static TcpProxyStats generateStats(Stats::Scope& scope);
@@ -230,6 +232,7 @@ public:
     absl::optional<std::chrono::milliseconds> access_log_flush_interval_;
     std::unique_ptr<TunnelingConfigHelper> tunneling_config_helper_;
     std::unique_ptr<OnDemandConfig> on_demand_config_;
+    bool receive_before_connect_;
   };
 
   using SharedConfigSharedPtr = std::shared_ptr<SharedConfig>;
@@ -281,6 +284,7 @@ public:
   }
   // This function must not be called if on demand is disabled.
   const OnDemandStats& onDemandStats() const { return shared_config_->onDemandConfig()->stats(); }
+  bool receiveBeforeConnect() { return shared_config_->receiveBeforeConnect(); }
   Random::RandomGenerator& randomGenerator() { return random_generator_; }
 
 private:
@@ -515,6 +519,8 @@ protected:
   uint32_t connect_attempts_{};
   bool connecting_{};
   bool downstream_closed_{};
+  Buffer::OwnedImpl early_data_buffer_{};
+  bool early_data_end_stream_{false};
 };
 
 // This class deals with an upstream connection that needs to finish flushing, when the downstream
-- 
2.39.2

