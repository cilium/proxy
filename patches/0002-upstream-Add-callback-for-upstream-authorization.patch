From 09806206d57c2cd4d124416ce57104d62e1157ed Mon Sep 17 00:00:00 2001
From: Jarno Rajahalme <jarno@isovalent.com>
Date: Fri, 23 Feb 2024 15:14:02 +0100
Subject: [PATCH 2/4] upstream: Add callback for upstream authorization

Add new StreamDecoderFilterCallbacks addUpstreamCallback() and
iterateUpstreamCallbacks(). Decoder filters can add callbacks using
addUpstreamCallback(), which will then get called after an upstream
connection has been established and all header transformations have been
performed, and just before upstream headers are encoded by the router
(encodeHeaders() call). If any of the callbacks returns 'false', the
router will issue a 403 local response instead of encoding the request
upstream.

This allows HTTP decoder filters to perform policy enforcement on the
upstream requests taking effect after all potential header
transformations have been performed.

Callbacks can safely refer to memory held by the filter instance
adding the callback, as the calls to the callbacks are only ever be
done from the router filter in the same filter chain.

Signed-off-by: Jarno Rajahalme <jarno@isovalent.com>

diff --git a/envoy/http/filter.h b/envoy/http/filter.h
index 88123f71b2..7b529bec55 100644
--- a/envoy/http/filter.h
+++ b/envoy/http/filter.h
@@ -463,6 +463,24 @@ public:
    */
   virtual void onDecoderFilterBelowWriteBufferLowWatermark() PURE;
 };
+
+/**
+ * UpstreamCallback can be used to reject upstream host selection made by the router.
+ * This callback is passed the StreamInfo, and the final headers that can be used by
+ * the callback to inform its decision.
+ *
+ * The callback is called right befere the request is encoded on the already connected
+ * upstream connection. At this stage all header manipulations in the Envoy configuration
+ * have been performed so that the callback may inspect the final headers.
+ *
+ * UpstreamCallback may not be called if a local reply is issued instead or forwarding
+ * the request.
+ *
+ * Returning 'true' allows the request to be forwarded. Returning 'false' prevents the
+ * request from being forwarded, and a 403 local response is issued instead.
+ */
+using UpstreamCallback = std::function<bool(Http::RequestHeaderMap&, StreamInfo::StreamInfo&)>;
+
 /**
  * Stream decoder filter callbacks add additional callbacks that allow a
  * decoding filter to restart decoding if they decide to hold data (e.g. for
@@ -759,6 +777,18 @@ public:
    */
   virtual bool iterateUpstreamCallbacks(Upstream::HostDescriptionConstSharedPtr,
                                         StreamInfo::StreamInfo&) PURE;
+
+  /*
+   * Adds the given callback to be executed later via 
+   */
+  virtual void addUpstreamCallback(const UpstreamCallback& cb) PURE;
+
+  /**
+   * Invokes all the added callbacks before forwarding requests from this stream upstream.
+   * Returns 'false' if any of the callbacks rejects the request, 'true' otherwise.
+   */
+  virtual bool iterateUpstreamCallbacks(Http::RequestHeaderMap&,
+                                        StreamInfo::StreamInfo&) PURE;
 };
 
 /**
diff --git a/source/common/http/async_client_impl.h b/source/common/http/async_client_impl.h
index c3849b092f..f66d5cd9ef 100644
--- a/source/common/http/async_client_impl.h
+++ b/source/common/http/async_client_impl.h
@@ -258,6 +258,11 @@ private:
                                 StreamInfo::StreamInfo&) override {
     return true;
   }
+  void addUpstreamCallback(const UpstreamCallback&) override {}
+  bool iterateUpstreamCallbacks(Http::RequestHeaderMap&,
+                                StreamInfo::StreamInfo&) override {
+    return true;
+  }
 
   // ScopeTrackedObject
   void dumpState(std::ostream& os, int indent_level) const override {
diff --git a/source/common/http/filter_manager.cc b/source/common/http/filter_manager.cc
index 5c46a28091..2d5a2d9983 100644
--- a/source/common/http/filter_manager.cc
+++ b/source/common/http/filter_manager.cc
@@ -1539,6 +1539,19 @@ bool FilterManager::createFilterChain() {
   return !upgrade_rejected;
 }
 
+void FilterManager::addUpstreamCallback(const UpstreamCallback& cb) {
+  decoder_filter_upstream_cbs_.emplace_back(cb);
+}
+  
+bool FilterManager::iterateUpstreamCallbacks(Http::RequestHeaderMap& headers,
+                                             StreamInfo::StreamInfo& upstream_info) {
+  bool accept = true;
+  for (const auto& cb : decoder_filter_upstream_cbs_) {
+    accept = accept && cb(headers, upstream_info);
+  }
+  return accept;
+}
+
 void ActiveStreamDecoderFilter::requestDataDrained() {
   // If this is called it means the call to requestDataTooLarge() was a
   // streaming call, or a 413 would have been sent.
@@ -1765,5 +1778,14 @@ bool ActiveStreamDecoderFilter::iterateUpstreamCallbacks(Upstream::HostDescripti
 
 }
 
+void ActiveStreamDecoderFilter::addUpstreamCallback(const UpstreamCallback& cb) {
+  parent_.addUpstreamCallback(cb);
+}
+
+bool ActiveStreamDecoderFilter::iterateUpstreamCallbacks(Http::RequestHeaderMap& headers,
+                                                         StreamInfo::StreamInfo& stream_info) {
+  return parent_.iterateUpstreamCallbacks(headers, stream_info);
+}
+
 } // namespace Http
 } // namespace Envoy
diff --git a/source/common/http/filter_manager.h b/source/common/http/filter_manager.h
index 3329051489..fd3b2b74db 100644
--- a/source/common/http/filter_manager.h
+++ b/source/common/http/filter_manager.h
@@ -243,6 +243,9 @@ struct ActiveStreamDecoderFilter : public ActiveStreamFilterBase,
   absl::optional<absl::string_view> upstreamOverrideHost() const override;
   bool iterateUpstreamCallbacks(Upstream::HostDescriptionConstSharedPtr host,
                                 StreamInfo::StreamInfo& stream_info) override;
+  void addUpstreamCallback(const UpstreamCallback& cb) override;
+  bool iterateUpstreamCallbacks(Http::RequestHeaderMap& headers,
+                                StreamInfo::StreamInfo& stream_info) override;
 
   // Each decoder filter instance checks if the request passed to the filter is gRPC
   // so that we can issue gRPC local responses to gRPC requests. Filter's decodeHeaders()
@@ -993,6 +996,9 @@ private:
     return request_metadata_map_vector_.get();
   }
 
+  void addUpstreamCallback(const UpstreamCallback&);
+  virtual bool iterateUpstreamCallbacks(Http::RequestHeaderMap&, StreamInfo::StreamInfo&);
+
   FilterManagerCallbacks& filter_manager_callbacks_;
   Event::Dispatcher& dispatcher_;
   // This is unset if there is no downstream connection, e.g. for health check or
@@ -1002,6 +1008,8 @@ private:
   Buffer::BufferMemoryAccountSharedPtr account_;
   const bool proxy_100_continue_;
 
+  std::vector<UpstreamCallback> decoder_filter_upstream_cbs_{};
+
   std::list<ActiveStreamDecoderFilterPtr> decoder_filters_;
   std::list<ActiveStreamEncoderFilterPtr> encoder_filters_;
   std::list<StreamFilterBase*> filters_;
diff --git a/source/common/router/upstream_codec_filter.cc b/source/common/router/upstream_codec_filter.cc
index 158d2b7297..8aee672826 100644
--- a/source/common/router/upstream_codec_filter.cc
+++ b/source/common/router/upstream_codec_filter.cc
@@ -58,6 +58,15 @@ Http::FilterHeadersStatus UpstreamCodecFilter::decodeHeaders(Http::RequestHeader
     return Http::FilterHeadersStatus::StopAllIterationAndWatermark;
   }
 
+  // This block has to be right before the encodeHeaders() (and any related logging) call below!
+  bool accepted = callbacks_->iterateUpstreamCallbacks(headers, callbacks_->streamInfo());
+  if (!accepted) {
+    callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::UnauthorizedExternalService);
+    callbacks_->sendLocalReply(Http::Code::Forbidden, "Access denied\r\n", nullptr,
+                               absl::nullopt, absl::string_view());
+    return Http::FilterHeadersStatus::StopIteration;
+  }
+
   ENVOY_STREAM_LOG(trace, "proxying headers", *callbacks_);
   calling_encode_headers_ = true;
   const Http::Status status =
diff --git a/source/common/router/upstream_request.cc b/source/common/router/upstream_request.cc
index 5ba6402235..750eccec7d 100644
--- a/source/common/router/upstream_request.cc
+++ b/source/common/router/upstream_request.cc
@@ -75,6 +75,15 @@ public:
                                                           details);
   }
   void executeLocalReplyIfPrepared() override {}
+
+  // Iterate upstream callbacks set on the downstream filter manager.
+  // Any upstream callbacks set by upstream filters will be ignored.
+  bool iterateUpstreamCallbacks(Http::RequestHeaderMap& headers,
+                                StreamInfo::StreamInfo& stream_info) override {
+    return upstream_request_.parent_.callbacks()->iterateUpstreamCallbacks(headers,
+									   stream_info);
+  }
+
   UpstreamRequest& upstream_request_;
 };
 
-- 
2.41.0

