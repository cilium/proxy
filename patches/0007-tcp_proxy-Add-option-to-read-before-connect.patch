From 8f7a283164515f1d941e59d3a782ed68d7d8c91f Mon Sep 17 00:00:00 2001
From: Jarno Rajahalme <jarno@isovalent.com>
Date: Tue, 27 Sep 2022 15:51:46 +0300
Subject: [PATCH 07/11] tcp_proxy: Add option to read before connect

Signed-off-by: Jarno Rajahalme <jarno@isovalent.com>
---
 .../network/tcp_proxy/v3/tcp_proxy.proto      |  7 +++++-
 source/common/tcp_proxy/tcp_proxy.cc          | 24 ++++++++++++++++---
 source/common/tcp_proxy/tcp_proxy.h           |  6 +++++
 3 files changed, 33 insertions(+), 4 deletions(-)

diff --git a/api/envoy/extensions/filters/network/tcp_proxy/v3/tcp_proxy.proto b/api/envoy/extensions/filters/network/tcp_proxy/v3/tcp_proxy.proto
index 5be0bcd853..e1dcb6d199 100644
--- a/api/envoy/extensions/filters/network/tcp_proxy/v3/tcp_proxy.proto
+++ b/api/envoy/extensions/filters/network/tcp_proxy/v3/tcp_proxy.proto
@@ -24,7 +24,7 @@ option (udpa.annotations.file_status).package_version_status = ACTIVE;
 // TCP Proxy :ref:`configuration overview <config_network_filters_tcp_proxy>`.
 // [#extension: envoy.filters.network.tcp_proxy]
 
-// [#next-free-field: 15]
+// [#next-free-field: 16]
 message TcpProxy {
   option (udpa.annotations.versioning).previous_message_type =
       "envoy.config.filter.network.tcp_proxy.v2.TcpProxy";
@@ -179,4 +179,9 @@ message TcpProxy {
   // is reached the connection will be closed. Duration must be at least 1ms.
   google.protobuf.Duration max_downstream_connection_duration = 13
       [(validate.rules).duration = {gte {nanos: 1000000}}];
+
+  // Keep downstream read enabled before connecting upstream.
+  // Note that enabling this may cause data to stall if preceding filter(s) do not buffer and/or
+  // re-inject data after the upstream connection has been established.
+  bool receive_before_connect = 15;
 }
diff --git a/source/common/tcp_proxy/tcp_proxy.cc b/source/common/tcp_proxy/tcp_proxy.cc
index 70427be439..286c222858 100644
--- a/source/common/tcp_proxy/tcp_proxy.cc
+++ b/source/common/tcp_proxy/tcp_proxy.cc
@@ -90,6 +90,8 @@ Config::SharedConfig::SharedConfig(
     on_demand_config_ =
         std::make_unique<OnDemandConfig>(config.on_demand(), context, *stats_scope_);
   }
+
+  receive_before_connect_ = config.receive_before_connect();
 }
 
 Config::Config(const envoy::extensions::filters::network::tcp_proxy::v3::TcpProxy& config,
@@ -207,7 +209,9 @@ void Filter::initialize(Network::ReadFilterCallbacks& callbacks, bool set_connec
   // Need to disable reads so that we don't write to an upstream that might fail
   // in onData(). This will get re-enabled when the upstream connection is
   // established.
-  read_callbacks_->connection().readDisable(true);
+  if (!config_->receiveBeforeConnect()) {
+    read_callbacks_->connection().readDisable(true);
+  }
   getStreamInfo().setDownstreamBytesMeter(std::make_shared<StreamInfo::BytesMeter>());
   getStreamInfo().setUpstreamInfo(std::make_shared<StreamInfo::UpstreamInfoImpl>());
 
@@ -417,8 +421,11 @@ Network::FilterStatus Filter::establishUpstreamConnection() {
     // cluster->stats().upstream_cx_none_healthy in the latter case.
     getStreamInfo().setResponseFlag(StreamInfo::ResponseFlag::NoHealthyUpstream);
     onInitFailure(UpstreamFailureReason::NoHealthyUpstream);
+    return Network::FilterStatus::StopIteration;
   }
-  return Network::FilterStatus::StopIteration;
+  // Allow OnData() to receive data before connect if so configured
+  return config_->receiveBeforeConnect()
+       ? Network::FilterStatus::Continue : Network::FilterStatus::StopIteration;
 }
 
 void Filter::onClusterDiscoveryCompletion(Upstream::ClusterDiscoveryStatus cluster_status) {
@@ -561,6 +568,12 @@ Network::FilterStatus Filter::onData(Buffer::Instance& data, bool end_stream) {
   if (upstream_) {
     getStreamInfo().getUpstreamBytesMeter()->addWireBytesSent(data.length());
     upstream_->encodeData(data, end_stream);
+  } else if (config_->receiveBeforeConnect()) {
+    // Buffer data received before upstream connection exists
+    early_data_buffer_.move(data);
+    if (!early_data_end_stream_) {
+      early_data_end_stream_ = end_stream;
+    }
   }
   // The upstream should consume all of the data.
   // Before there is an upstream the connection should be readDisabled. If the upstream is
@@ -662,7 +675,12 @@ void Filter::onUpstreamConnection() {
   connecting_ = false;
   // Re-enable downstream reads now that the upstream connection is established
   // so we have a place to send downstream data to.
-  read_callbacks_->connection().readDisable(false);
+  if (!config_->receiveBeforeConnect()) {
+    read_callbacks_->connection().readDisable(false);
+  } else if (early_data_buffer_.length() > 0) {
+    upstream_->encodeData(early_data_buffer_, early_data_end_stream_);
+    ASSERT(0 == early_data_buffer_.length());
+  }
 
   read_callbacks_->upstreamHost()->outlierDetector().putResult(
       Upstream::Outlier::Result::LocalOriginConnectSuccessFinal);
diff --git a/source/common/tcp_proxy/tcp_proxy.h b/source/common/tcp_proxy/tcp_proxy.h
index c64bec9776..6af48f1538 100644
--- a/source/common/tcp_proxy/tcp_proxy.h
+++ b/source/common/tcp_proxy/tcp_proxy.h
@@ -21,6 +21,7 @@
 #include "envoy/upstream/cluster_manager.h"
 #include "envoy/upstream/upstream.h"
 
+#include "source/common/buffer/buffer_impl.h"
 #include "source/common/common/logger.h"
 #include "source/common/network/cidr_range.h"
 #include "source/common/network/filter_impl.h"
@@ -189,6 +190,7 @@ public:
         return OnDemandConfigOptConstRef();
       }
     }
+    bool receiveBeforeConnect() { return receive_before_connect_; }
 
   private:
     static TcpProxyStats generateStats(Stats::Scope& scope);
@@ -202,6 +204,7 @@ public:
     absl::optional<std::chrono::milliseconds> max_downstream_connection_duration_;
     std::unique_ptr<TunnelingConfigHelper> tunneling_config_helper_;
     std::unique_ptr<OnDemandConfig> on_demand_config_;
+    bool receive_before_connect_;
   };
 
   using SharedConfigSharedPtr = std::shared_ptr<SharedConfig>;
@@ -250,6 +253,7 @@ public:
   }
   // This function must not be called if on demand is disabled.
   const OnDemandStats& onDemandStats() const { return shared_config_->onDemandConfig()->stats(); }
+  bool receiveBeforeConnect() { return shared_config_->receiveBeforeConnect(); }
 
 private:
   struct SimpleRouteImpl : public Route {
@@ -478,6 +482,8 @@ protected:
   uint32_t connect_attempts_{};
   bool connecting_{};
   bool downstream_closed_{};
+  Buffer::OwnedImpl early_data_buffer_{};
+  bool early_data_end_stream_{false};
 };
 
 // This class deals with an upstream connection that needs to finish flushing, when the downstream
-- 
2.36.0

